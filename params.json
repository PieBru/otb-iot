{"name":"otb-iot","tagline":"Out of The Box Internet Of Things","body":"---\r\nlayout: page\r\ntitle:  \"otb-iot\"\r\npermalink: /otb-iot/\r\n---\r\n\r\n# Out of the Box - Internet of Things\r\n\r\n## Introduction\r\n\r\n[otb-iot](https://piersfinlayson.github.io/otb-iot/) is software for ESP8266 devices which is intended to make the ESP8266 quick and easy to deploy for _real_ applications, and to be _robust_.\r\n\r\nThere's a huge amount of hacking and playing going on with the ESP8266 today, which is a fantastic thing for all hobbyists, enthusiasts and those looking to develop deployable products.  But while it's very quick and easy to get stuff running on the ESP8266, and even to cobble together something that provides a lot of function, making it fully featured enough to actually deploy and maintain in the field takes effort.\r\n\r\nThis is where otb-iot comes in - it's a complete software image for the ESP8266 which is intended to be this robust and deployable solution.\r\n\r\n## Getting Started\r\n\r\nI've tried to make it as easy as possible to get started.  There are five main steps:\r\n\r\n* Install the [open-esp-sdk](https://github.com/pfalcon/esp-open-sdk)\r\n* (Optional) Install [platformio](http://platformio.org/#!/get-started)\r\n* Clone the otb-iot software from [github](https://github.com/piersfinlayson/otb-iot)\r\n* Build it\r\n* Install it\r\n\r\nI strongly recommend using linux as the build environment.  If like me you won't touch a linux desktop environment with a barge-pole you may want to run linux as a virtual machine within a hypervisor such as [VirtualBox](https://www.virtualbox.org/), and then ssh into it from your Windows or Mac.\r\n\r\n### open-esp-sdk\r\n\r\nThe simple instructions to install this are [here](https://github.com/pfalcon/esp-open-sdk#requirements-and-dependencies).  It takes me about an hour from scratch to install this piece - as I have pretty slow internet access.\r\n\r\n### platformio\r\n\r\nThis is only used by the otb-iot Makefile to provide convenient serial monitor.  Doubtless there's easier ways to get this function - but I started out using the ESP8266 Arduino framework and platformio is awesome at making this easy.  Follow the CLI instructions [here](http://platformio.org/#!/get-started).\r\n\r\n### otb-iot\r\n\r\n#### Getting the software\r\n\r\n    git clone https://github.com/piersfinlayson/otb-iot.git\r\n\r\n\r\n#### Building it\r\n\r\n* Go to the directory you've cloned otb-iot\r\n\r\n      cd otb-iot\r\n\r\n* Ensure you expose SDK_BASE from your shell, pointing at the base open-esp-sdk directory - or uncomment this line in the Makefile and make sure it's set correctly:\r\n\r\n      # SDK_BASE = /opt/esp-open-sdk\r\n\r\n* Check ESP_SDK is set correctly in the Makefile to point to the Espressif SDK within the open-esp-sdk directory:\r\n\r\n      ESP_SDK = esp_iot_sdk_v1.4.0\r\n\r\n* Run make\r\n\r\n      make\r\n\r\n#### Installing it\r\n\r\n* Plug your ESP8266 to a USB port on your machine - either using the port provided by a dev board like Nodemcu or the WeMos D1-mini, or using a separate FTDI/CH340/etc serial to USB converter.  If you're using linux in a VM you'll need to set up a rule within your hypervisor to route the USB device to the VM.  Note only boards with 4MB (32Mbit) of flash (or greater) are currently supported.  This seems to be all of the current batch of ESP-12s coming out of China at the moment.\r\n\r\n* Use make to flash your device:\r\n\r\n      make flash_initial\r\n\r\nThat's it - you should now be up and running\r\n\r\n#### Using otb-iot\r\n\r\nThere's more detailed information later, but in a nutshell to start using otb-iot:\r\n* Connect to the \"OTB-IOT.XXXXXX\" WiFi Access Point which will now be available.* This should activate captive portal on your device, but if not point a browser at http://192.168.4.1\r\n* Configure\r\n  * Your WiFi credentials (access point SSID and password)\r\n  * Your MQTT server details (IP address and any username/password)\r\n* Hit submit\r\n\r\nThe ESP8266 will now reboot and should connect to your WiFi network.  The WiFi AP will be exposed at all times to allow you to reconfigure the above details while MQTT isn't connected.  When MQTT is connected by default the AP will turn off, but you can override this behaviour both within the captive portal, and using MQTT if you desire.\r\n\r\nYou can now start communicating with your ESP8266 over MQTT.  To check it's responding send to topic _/otb_iot/all/system_ message _ping_.  You should get a message _pong_ sent to topic _/otb_iot/all/status_. \r\n\r\nTo use mosquitto to send and receive MQTT messages run this command in one shell:\r\n\r\n    mosquitto_sub -v -h _your_mqtt_server_ -t \r\n\r\nto listen for all MQTT publishes.\r\n\r\nAnd then in another:\r\n\r\n    mosquitto_pub -h _your_mqtt_server_ -t /otb_iot/all/system -m ping\r\n    \r\nto send the ping.  You should see a message like this in response:\r\n\r\n    /otb_iot/xxxxxx/status pong\r\n\r\nwhere xxxxxx is the chip ID of your ESP8266.\r\n\r\n## IOT Function\r\n\r\nToday otb-iot provides the following IOT functionality:\r\n\r\n* Support for reporting temperatures from [DS18B20](http://www.hobbytronics.co.uk/ds18b20-arduino) sensors over MQTT\r\n\r\n* Ability to set GPIO output to high and low over MQTT\r\n\r\n* Access to various management capabity over MQTT including\r\n\r\n  * Over the Air (OTA) upgrades\r\n  * Reconfiguration\r\n  * Querying wifi signal strength\r\n  * Querying GPIO status\r\n  * Reset/reboot\r\n  * Retrieving logs and last reboot reason\r\n\r\n## Supported boards\r\n\r\nAnything with at least 4MB (32MBit) of flash should be supported.  It would probably be possible to squeeze down to 2MB fairly easily, but I've not seen any 2MB boards out there.  As otb-iot includes 3 boot images for robustness, squeezing into 1MB would be problematic.\r\n\r\nThis means that any recent (early 2016) ESP-12 should work.  Most of my testing has been done with:\r\n\r\n* [WeMos D1-mini](http://www.wemos.cc/wiki/doku.php?id=en:start) (my favourite)\r\n\r\n* [Nodemcu V3 from LoLin](https://cknodemcu.wordpress.com/2015/11/13/nodemcu-variants/) (a bit big)\r\n\r\nTo see check your board size run:\r\n\r\n    esptool.py flash_id\r\n\r\nIf you get 4016 reported you're good to go.\r\n\r\n## MQTT \"API\"\r\n\r\nI took the decision to use [MQTT](http://mqtt.org/) as the primary communication protocol because\r\n* it's suited to IOT applications due to its lightweight nature (both requiring little footprint for implementation, and having little protocol overhead on messages)\r\n* to keep functionality limited - remember a focus here is to be robust and stable, which is hard with a plethora of function.\r\n\r\nTherefore only very limited configuration is available over WiFi/IP.\r\n\r\n### Sending and Receiving Messages\r\n\r\nTo send messages to the otb-iot device, use one of the following topics:\r\n\r\n    /otb_iot/all/system - Addresses all otb-iot devices attached to your MQTT broker\r\n    /otb_iot/chipid/system - To just address your device\r\n    /otb_iot/loc1/loc2/loc3/chipid/system - To just address your device, if you've set the loc1, loc2 and loc3 values\r\n    \r\nRegular status updates and responses to messages sent on the system topic will be sent using one of the following topics:\r\n\r\n    /otb_iot/chipid/status - if loc1, loc2 and loc3 aren't set\r\n    /otb_iot/loc1/loc2/loc3/chipid/status - if they are set\r\n    \r\nThe otb-iot device may also send using one of the following topics when reporting serious errors:\r\n\r\n    /otb_iot/chipid/error\r\n    /otb_iot/loc1/loc2/loc3/chipid/error\r\n\r\nTemperature readings will be sent once a minute for each attached DS18B20 using:\r\n\r\n    /otb_iot/loc1/loc2/loc3/chipid/temp/sensor_loc/sensorid\r\n    \r\nLoc1, loc2 and loc3 will be included only if configured, as will sensor_loc.  All temperature readings are in Celsius, and the DS18B20 claims +-0.5C accuracy.\r\n\r\n### System Messages\r\n\r\nThe support messages are as follows:\r\n\r\nTo set config values:\r\n\r\n    config:set:field:value\r\n\r\nField may be one of:\r\n\r\n    ssid      # WiFi SSID\r\n    password  # WiFi Password\r\n    loc1      # Location 1 to use in topics\r\n    loc2      # Location 2 to use in topics\r\n    loc3      # Location 3 to use in topics\r\n    keep_ap_active  # Keep AP active when MQTT connected\r\n\r\nTo set DS18B20 sensor_loc information:\r\n\r\n    config:set:ds18b20:addr:loc  # To set a location\r\n    config:set:ds18b20:clear     # To clear all DS18B20 location information\r\n    \r\nThe address format for DS18B20 sensors is 28-112233445566 (not including checksum)\r\n\r\nTo retrieve config values:\r\n\r\n    config:get:field     # Values as above\r\n    config:get:ds18b20s  # To get the number of _configured_ DS18B20s (i.e. locations)\r\n    config:get:ds18b20:addr   # To get DS18B20 info by address\r\n    config:get:ds18b20:loc    # To get DS18B20 info by location\r\n    config:get:ds18b20:slot   # To get DS18B20 by slot - up to 8 (0-7) are supported \r\n\r\nTo get info about actual connected DS18B20s (as opposed to configured address/locations):\r\n\r\n    ds18b20:get_num          # Gets number of devices connected at last book\r\n    ds18b20:get:ds18b20:num  # Where num starts at 0 and goes up to 7 depending on number of connected - returns address in above format\r\n\r\nTo retrieve received signal strength of connected AP:\r\n\r\n    rssi:get\r\n\r\nTo get current free heap size of ESP8266:\r\n\r\n    heap_size:get\r\n\r\nTo reset (reboot) the device use either:\r\n\r\n    reset\r\n    reboot\r\n\r\nTo ping the device over MQTT:\r\n\r\n    ping\r\n\r\nTo retrieve last reboot reason:\r\n\r\n    reason:reboot\r\n\r\nTo get otb-iot software version;\r\n\r\n    version:get\r\n    \r\nTo get ESP8266 chip ID:\r\n\r\n    chip_id:get\r\n\r\nTo get software compile date:\r\n\r\n    compile_date:get\r\n\r\nTo get software compile time:\r\n\r\n    compile_time:get\r\n\r\nTo see which boot slot the software is currently running from:\r\n\r\n    boot_slot:get\r\n\r\nTo set the slot to boot from at next reset:\r\n\r\n    boot_slot:set:value  # 0 or 1\r\n\r\nTo set GPIO value:\r\n\r\n    gpio:set:pin_no:value  # value = 0 or 1, pin=2 is reserved for DS18B20s\r\n\r\nTo apply and save GPIO value so it's applied after next reset (NOT YET IMPLEMENTED):\r\n\r\n    gpio:save:pin_no:value\r\n\r\nTo get current pin value:\r\n\r\n    gpio:get:pin_no\r\n\r\nTo update to new software, which installs in the non-current boot slot and reboots when done:    \r\n    \r\n    update:ip_address:port:path    # Uses HTTP for update\r\n    upgrade:ip_address:port:path   # Uses HTTP for update\r\n\r\nTo retrieve logs from RAM:\r\n\r\n    logs:ram:get:num   # 0 = most recent, 1 is next, 2 is next, etc\r\n\r\nTo retreive logs from flash where they are stored in the event of a serious problem leading to reboot.  (While storing of logs in this case is supported, retrieving over MQTT is NOT YET IMPLEMENTED):    \r\n\r\n    logs:flash:get:num  (0 = most recent, 1 is next, …)\r\n    \r\n### Status Messages\r\n\r\notb-iot will send responses to system messages using status messages.  It may also send unsolicited messages in some cases - like when rebooting after an upgrade.\r\n\r\nThe messages that may be sent are as follows:\r\n\r\n    config:set:ok(:further_info)\r\n    config:set:error(:further_info)\r\n    config:get:ok:value(:further_info)\r\n    config:get:error(:further_info)\r\n    gpio:set:ok(:further_info)\r\n    gpio:set:error(:further_info)\r\n    gpio:get:ok:value\r\n    gpio:get:error(:further_info)\r\n    boot_slot:set:ok(:further_info)\r\n    boot_slot:set:error(:further_info)\r\n    boot_slot:get:ok:value\r\n    boot_slot:get:error(:further_info)\r\n    heap_size:get:ok:value\r\n    heap_size:get:error(:further_info)\r\n    pong(:further_info)\r\n    error(:further_info)\r\n    reset:ok(:further_info)\r\n    reboot:ok(:further_info)\r\n    reset:error(:further_info)\r\n    reboot:error(:further_info)\r\n    update:ok(:further_info)\r\n    update:error(:further_info)\r\n    booted unsolicited\r\n    version:version_id\r\n    build_date:build_date\r\n    build_time:build_time\r\n    chipid:chipid \r\n    reason:further_info\r\n    offline unsolicited (MQTT Last Will and Testament generated by the MQTTbroker)\r\n    \r\n### Error Messages\r\n\r\nIn the case of a serious error hit by otb-iot it will attempt to send on the error topic a message containing error details\r\n\r\n### Message format\r\n\r\nAs can be seen colon (:) is used to separate fields and parameters in otb-iot MQTT messages.  Colons are not therefore support in values themselves.\r\n\r\nIn addition whitespace will not be used - any whitespace characters will be converted to _ before being sent in status or error messages.\r\n\r\n## Logging\r\n\r\notb-iot outputs useful logs over serial.  It also has a circular log buffer in RAM which can be queried via MQTT.  In the event of a serious error leading to a reset forced by the otb-iot software this will be written to flash.  In the future this flash region will be queryable via MQTT.\r\n\r\notb-iot logs fall into the following categories:\r\n\r\n* ERROR\r\n* WARN\r\n* INFO\r\n* DEBUG (compiled out by default)\r\n\r\n## Robustness\r\n\r\nA number of approaches are taken to ensuring otb-iot's robustness:\r\n\r\n* Starting the WiFi AP if MQTT fails, so WiFi and MQTT details can easily be reconfigured as necessary.\r\n\r\n* Hardening of the various function provided, handling error codes, and taking corrective recovery on errors.\r\n\r\n* Ongoing checking of internal consistency.\r\n\r\n* Substantial logging via serial and access to this over MQTT.\r\n\r\n* Ability to query device in an automated fashion over MQTT using provided APIs.\r\n\r\n* Limiting the exposed function.\r\n\r\n* Checksuming of software images, and fallback to alternative image.\r\n\r\n* \"Factory\" Installed 3rd software recovery image, not upgradeable via OTA to allow recovery.\r\n\r\nThis is still a work in progress.\r\n\r\n## Security\r\n\r\nThis is a work in progress.  Currently MQTT implementation does not support SSL.  WiFi AP passwords are not logged and are not queryable via APIs.\r\n\r\n## Third Party Component Usage\r\n\r\n* [pfalcon's Open ESP SDK](https://github.com/pfalcon/esp-open-sdk)\r\n\r\n* [Espressif ESP non-RTOS SDK](http://bbs.espressif.com/viewtopic.php?f=46&t=850)\r\n\r\n* [tuanpmt's MQTT](https://github.com/tuanpmt/esp_mqtt)\r\n\r\n* [raburton's rboot](https://github.com/raburton/rboot) and [Esptool2](https://github.com/raburton/esptool2)\r\n\r\n* [Spritetm's esphttpd](https://github.com/Spritetm/esphttpd)\r\n\r\n* [Paul Stroffgen's One Wire library](http://www.pjrc.com/teensy/td_libs_OneWire.html)\r\n\r\n* [Necromant's adaption of the One Wire library in esp8266-frankenstein](https://github.com/nekromant/esp8266-frankenstein)\r\n\r\n## otb-iot License\r\n\r\nThe otb-iot software is licensed under the [GNU General Public License version 3 (GPLv3)](http://www.gnu.org/licenses/).\r\n\r\nAll of the original versions of the third party code are licensed under their respective licenses, with any new code licensed under the GPLv3.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}